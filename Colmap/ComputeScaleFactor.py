import re
import numpy as np
from math import radians, cos, sin, asin, sqrt
import geopy.distance

# Function used to extract the gps values from the name string, same as the one used for modifying the EXIF
def extract_ALLdata_name(file_name):
    # Defining the regex used to extract every single parameter from the filename
    pattern = r"lat(-?\d*\.\d+)_lon(-?\d*\.\d+)_alt(-?\d*\.\d+)_pitch(-?\d*\.\d+)_yaw(-?\d*\.\d+)_roll(-?\d*\.\d+)"
    # Search for match in the filename
    match = re.search(pattern, file_name)
    if match:
        # Extract all the values from the strinf using the regex
        value_lat   = float(match.group(1))
        value_lon   = float(match.group(2))
        value_alt   = float(match.group(3))
        value_pitch = float(match.group(4))
        value_yaw   = float(match.group(5))
        value_roll  = float(match.group(6))

        # Create list containing the single values
        list_values = [value_lat, value_lon, value_alt, value_pitch, value_yaw, value_roll]
        return list_values
    else:
        raise ValueError("no numeric value.")
    
# PATH to images.txt file generated by COLMAP
f = open(r"C:\Users\tobia\Downloads\Dataset\Strada\images.txt", "r")

# Extract each line
Lines = f.readlines()
 
# Split data (2 lines per image). Get the data of 2 random cameras
cam1 = Lines[4].split(" ")
cam50 = Lines[94].split(" ")

# Extract the tx, ty, tz positions of the cameras
pos1 = np.array([float(cam1[5]), float(cam1[6]), float(cam1[7])])
pos50 = np.array([float(cam50[5]), float(cam50[6]), float(cam50[7])])

# Extract the image filename (it contains gps coords)
gps1 = extract_ALLdata_name(cam1[9])
gps50 = extract_ALLdata_name(cam50[9])

# Compute euclidean distance of the cameras wrt the generated model space
squared_dist = np.sum((pos1-pos50)**2, axis=0)
model_dist = np.sqrt(squared_dist)
print(model_dist)

# Compute the distance of the cameras wrt world space by using the haversine formula
coords_1 = (gps1[0], gps1[1])
coords_2 = (gps50[0], gps50[1])

gps_dist = geopy.distance.geodesic(coords_1, coords_2).km * 1000 # in meters
print(gps_dist)

# Compute the scale factor between the two distances
sf = gps_dist / model_dist
print("Scale factor: ", sf)

'''
# OTHER method to compute distance using gps coords (same as above, but does not use a library, instead it computes every single passage):

from math import sin, cos, sqrt, atan2, radians

# Approximate radius of earth in km
R = 6373.0

lat1 = radians(gps1[0])
lon1 = radians(gps1[1])
lat2 = radians(gps50[0])
lon2 = radians(gps50[1])

dlon = lon2 - lon1
dlat = lat2 - lat1

a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
c = 2 * atan2(sqrt(a), sqrt(1 - a))

distance = R * c

print("Result: ", distance*1000) # in meters
'''