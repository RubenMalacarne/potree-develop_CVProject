import re
import numpy as np
from math import radians, cos, sin, asin, sqrt
import geopy.distance

# Function used to extract the gps values from the name string, same as the one used for modifying the EXIF
def extract_ALLdata_name(file_name):
    # Defining the regex used to extract every single parameter from the filename
    pattern = r"lat(-?\d*\.\d+)_lon(-?\d*\.\d+)_alt(-?\d*\.\d+)_pitch(-?\d*\.\d+)_yaw(-?\d*\.\d+)_roll(-?\d*\.\d+)"
    # Search for match in the filename
    match = re.search(pattern, file_name)
    if match:
        # Extract all the values from the strinf using the regex
        value_lat   = float(match.group(1))
        value_lon   = float(match.group(2))
        value_alt   = float(match.group(3))
        value_pitch = float(match.group(4))
        value_yaw   = float(match.group(5))
        value_roll  = float(match.group(6))

        # Create list containing the single values
        list_values = [value_lat, value_lon, value_alt, value_pitch, value_yaw, value_roll]
        return list_values
    else:
        raise ValueError("no numeric value.")
    
# PATH to images.txt file generated by COLMAP
f = open(PATH, "r")            # Need to change the path!

# Extract each line
Lines = f.readlines()

# Get the number of images (-4 because there a 3 descriptor lines, /2 because there are 2 lines per image)
l = int((len(Lines)-4) / 2)
# Initialize the scale factor and the number of images comparisons
scale_factor = 0.0
times = 0

# Loop through each image and compute distance to all the other images
for i in range(l):
    print(i+1, "/", l)
    cami = Lines[(i*2)+4].split(" ")
    for j in range(l):
        # If the same image, skip
        if i == j:
            continue
        camj = Lines[(j*2)+4].split(" ")

        # Extract the tx, ty, tz positions of the cameras
        posi = np.array([float(cami[5]), float(cami[6]), float(cami[7])])
        posj = np.array([float(camj[5]), float(camj[6]), float(camj[7])])

        # Extract the image filename (it contains gps coords)
        gpsi = extract_ALLdata_name(cami[9])
        gpsj = extract_ALLdata_name(camj[9])

        # Compute euclidean distance of the cameras wrt the generated model space
        squared_dist = np.sum((posi-posj)**2, axis=0)
        model_dist = np.sqrt(squared_dist)
        #print(model_dist)

        # Compute the distance of the cameras wrt world space by using the haversine formula
        coords_1 = (gpsi[0], gpsi[1])
        coords_2 = (gpsj[0], gpsj[1])

        gps_dist = geopy.distance.geodesic(coords_1, coords_2).km * 1000 # in meters
        #print(gps_dist)

        # Compute the scale factor between the two distances
        scale_factor += gps_dist / model_dist
        times += 1

print(times)
print(scale_factor / times)


'''
# OTHER method to compute distance using gps coords (same as above, but does not use a library, instead it computes every single passage):

from math import sin, cos, sqrt, atan2, radians

# Approximate radius of earth in km
R = 6373.0

lat1 = radians(gpsi[0])
lon1 = radians(gpsi[1])
lat2 = radians(gpsj[0])
lon2 = radians(gpsj[1])

dlon = lon2 - lon1
dlat = lat2 - lat1

a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
c = 2 * atan2(sqrt(a), sqrt(1 - a))

distance = R * c

print("Result: ", distance*1000) # in meters
'''